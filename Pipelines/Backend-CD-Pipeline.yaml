#trigger:
#  branches:
#    include:
#      - main

resources:
  pipelines:
    - pipeline: backendCI
      source: backend-ci
      trigger:
        branches:
          include:
            - main

variables:
  myServiceConnection: "MyServiceConnection"
  resourceGroup: "rg-banking-app"
  aksCluster: "aks-banking-cluster"
  namespace: "default"
  deploymentFile: "kubernetes/prod/deployment.yaml"
  secretFile: "kubernetes/prod/secret.yaml"
  acrName: "acrbankingapp"
  imageName: "backend"
  imageTag: "$(resources.pipeline.backendCI.runId)"
  keyVaultName: "kvBankingApp"

stages:
  - stage: Deploy
    displayName: "Deploy Backend to AKS"
    #condition: succeeded('resources.pipeline.backendCI')
    jobs:
      - job: DeployToAKS
        pool:
          name: Default
        steps:
          - checkout: self

          # Fetch all secrets from Key Vault
          - task: AzureKeyVault@2
            inputs:
              azureSubscription: "$(myServiceConnection)"
              KeyVaultName: "$(keyVaultName)"
              # Key Vault secret names
              SecretsFilter: '*'
              RunAsPreJob: true
            displayName: "Fetch Secrets from Azure Key Vault"

          - task: FileTransform@1
            displayName: 'File Transform - Apply secret.yaml'
            inputs:
              folderPath: '$(System.DefaultWorkingDirectory)'
              fileType: 'yaml'
              targetFiles: 'kubernetes/prod/secret.yaml'
              variableSubstitutions: true



          - task: Kubernetes@1
            displayName: 'Apply secret.yaml to AKS'
            inputs:
                connectionType: 'Azure Resource Manager'
                azureSubscription: 'MyServiceConnection'
                azureResourceGroup: 'rg-banking-app'
                kubernetesCluster: 'aks-banking-cluster'
                namespace: 'default'
                command: 'apply'
                useConfigurationFile: true
                configuration: 'kubernetes/prod/secret.yaml'

          # Replace placeholders in secret YAML and deployment YAML
          - powershell: |
              Write-Host "Injecting secrets into YAML and replacing deployment placeholders..."
#              $secretFile = "$(secretFile)"
              $deploymentFile = "$(deploymentFile)"
#
#              function Get-EnvEither($underscore, $hyphen) {
#                  # Try underscore first, then hyphen. Use Get-Item to safely access names with hyphens.
#                  $val = $null
#                  try { $val = (Get-Item -Path ("Env:\" + $underscore) -ErrorAction SilentlyContinue).Value } catch {}
#                  if (-not $val) {
#                      try { $val = (Get-Item -Path ("Env:\" + $hyphen) -ErrorAction SilentlyContinue).Value } catch {}
#                  }
#                  return $val
#              }
#
#              # Read secrets (accept both underscore and hyphen variants)
#              $DB_USER        = Get-EnvEither 'DB_USER' 'DB-USER'
#              $DB_PASSWORD    = Get-EnvEither 'DB_PASSWORD' 'DB-PASSWORD'
#              $DB_URL         = Get-EnvEither 'DB_URL' 'DB-URL'
#              $MAIL_USERNAME  = Get-EnvEither 'MAIL_USERNAME' 'MAIL-USERNAME'
#              $MAIL_PASSWORD  = Get-EnvEither 'MAIL_PASSWORD' 'MAIL-PASSWORD'
#              $JWT_SECRET_KEY = Get-EnvEither 'JWT_SECRET_KEY' 'JWT-SECRET-KEY'
#
              # Pipeline variables (expanded by Azure DevOps at runtime)
              $ACR_NAME     = "$(acrName)"
              $IMAGE_NAME   = "$(imageName)"
              $IMAGE_TAG    = "$(imageTag)"
#
#              # Validate files
#              if (-not (Test-Path $secretFile)) { Write-Error "Secret file not found: $secretFile"; exit 1 }
#              if (-not (Test-Path $deploymentFile)) { Write-Error "Deployment file not found: $deploymentFile"; exit 1 }
#
#              # Show which secret env vars exist (names only)
#              Get-ChildItem Env: | Where-Object { $_.Name -match 'DB|MAIL|JWT' } | Sort-Object Name | Select-Object Name
#
#              # Print presence/masked info for the specific secrets (avoid printing values)
#              Write-Host "`n--- Secret Presence (masked) ---"
#              # assign statuses explicitly to avoid inline conditional expressions
#              if ($DB_USER) {
#                  $dbUserStatus = '[SET]'
#              } else {
#                  $dbUserStatus = '<missing>'
#              }
#              if ($DB_PASSWORD) {
#                  $dbPasswordStatus = '[SET]'
#              } else {
#                  $dbPasswordStatus = '<missing>'
#              }
#              if ($DB_URL) {
#                  $dbUrlStatus = '[SET]'
#              } else {
#                  $dbUrlStatus = '<missing>'
#              }
#              if ($MAIL_USERNAME) {
#                  $mailUserStatus = '[SET]'
#              } else {
#                  $mailUserStatus = '<missing>'
#              }
#              if ($MAIL_PASSWORD) {
#                  $mailPasswordStatus = '[SET]'
#              } else {
#                  $mailPasswordStatus = '<missing>'
#              }
#              if ($JWT_SECRET_KEY) {
#                  $jwtStatus = '[SET]'
#              } else {
#                  $jwtStatus = '<missing>'
#              }
#
#              Write-Host "DB_USER: $dbUserStatus"
#              Write-Host "DB_PASSWORD: $dbPasswordStatus"
#              Write-Host "DB_URL: $dbUrlStatus"
#              Write-Host "MAIL_USERNAME: $mailUserStatus"
#              Write-Host "MAIL_PASSWORD: $mailPasswordStatus"
#              Write-Host "JWT_SECRET_KEY: $jwtStatus"
#
#              # Replace placeholders in secret YAML (only when the secret value exists)
#              $content = Get-Content $secretFile -Raw
#              if ($DB_USER)        { $content = $content -replace "<DB_USER>", [Regex]::Escape($DB_USER) }
#              if ($DB_PASSWORD)    { $content = $content -replace "<DB_PASSWORD>", [Regex]::Escape($DB_PASSWORD) }
#              if ($DB_URL)         { $content = $content -replace "<DB_URL>", [Regex]::Escape($DB_URL) }
#              if ($MAIL_USERNAME)  { $content = $content -replace "<MAIL_USERNAME>", [Regex]::Escape($MAIL_USERNAME) }
#              if ($MAIL_PASSWORD)  { $content = $content -replace "<MAIL_PASSWORD>", [Regex]::Escape($MAIL_PASSWORD) }
#              if ($JWT_SECRET_KEY) { $content = $content -replace "<JWT_SECRET_KEY>", [Regex]::Escape($JWT_SECRET_KEY) }
#
#              Set-Content -Path $secretFile -Value $content -Force
#              Write-Host "Replaced secrets in $secretFile"

              # Replace ACR/image details in deployment YAML
              (Get-Content $deploymentFile -Raw) `
                  -replace "<ACR_NAME>", $ACR_NAME `
                  -replace "<IMAGE_NAME>", $IMAGE_NAME `
                  -replace "<TAG>", $IMAGE_TAG |
                  Set-Content $deploymentFile -Force

              Write-Host "Replaced image details in $deploymentFile"
            displayName: "Replace Secret & Deployment Placeholders"

          # Deploy to AKS using PowerShell script
          - task: AzurePowerShell@5
            inputs:
              azureSubscription: "$(myServiceConnection)"
              ScriptType: 'FilePath'
              ScriptPath: './Pipelines/Backend-CD.ps1'
              ScriptArguments: '$(resourceGroup) $(aksCluster) $(namespace) $(deploymentFile) $(secretFile) $(acrName) $(imageName) $(imageTag)'
              azurePowerShellVersion: 'LatestVersion'
            displayName: "Deploy Backend to AKS"

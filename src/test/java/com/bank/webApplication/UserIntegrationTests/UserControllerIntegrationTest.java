package com.bank.webApplication.UserIntegrationTests;

import com.bank.webApplication.Dto.UserDto;
import com.bank.webApplication.Entity.AuthEntity;
import com.bank.webApplication.Entity.Role;
import com.bank.webApplication.Entity.UserEntity;
import com.bank.webApplication.Repository.AuthRepository;
import com.bank.webApplication.Repository.UserRepository;
import com.fasterxml.jackson.databind.ObjectMapper;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.autoconfigure.web.servlet.AutoConfigureMockMvc;
import org.springframework.boot.test.context.SpringBootTest;
import org.springframework.http.MediaType;
import org.springframework.security.authentication.UsernamePasswordAuthenticationToken;
import org.springframework.security.core.authority.SimpleGrantedAuthority;
import org.springframework.security.core.context.SecurityContextHolder;
import org.springframework.security.crypto.password.PasswordEncoder;
import org.springframework.test.context.ActiveProfiles;
import org.springframework.test.web.servlet.MockMvc;
import org.springframework.transaction.annotation.Transactional;

import java.util.Collections;
import java.util.UUID;

import static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.*;
import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.*;

@SpringBootTest
@AutoConfigureMockMvc
@ActiveProfiles("test")
@Transactional
class UserControllerIntegrationTest {

    @Autowired
    private MockMvc mockMvc;

    @Autowired
    private UserRepository userRepository;

    @Autowired
    private AuthRepository authRepository;

    @Autowired
    private PasswordEncoder passwordEncoder;

    @Autowired
    private ObjectMapper objectMapper;

    private UUID testUserId;
    private UserEntity testUser;

    @BeforeEach
    void setUp() {
        // Clear any existing authentication
        SecurityContextHolder.clearContext();

        // Create and save AuthEntity first ( to let Hibernate generate the ID and then use that)
        AuthEntity testAuth = AuthEntity.builder()
                .username("testuser")
                .password(passwordEncoder.encode("password"))
                .role(Role.USER)
                .build();
        AuthEntity savedAuth = authRepository.save(testAuth);
        testUserId = savedAuth.getId(); // Get the generated ID

        // Create and save UserEntity with the same ID
        testUser = new UserEntity(
                testUserId,
                "John Doe",
                "john.doe@example.com",
                "1234567890",
                "2023-01-01 10:00:00",
                "2023-01-01 10:00:00",
                "123 Main St",
                Role.USER
        );
        userRepository.save(testUser);

        // Set up security context for authenticated user
        setupSecurityContext(testUserId.toString());
    }

    private void setupSecurityContext(String userId) {
        UsernamePasswordAuthenticationToken authentication =
                new UsernamePasswordAuthenticationToken(
                        userId,
                        null,
                        Collections.singletonList(new SimpleGrantedAuthority("USER"))
                );
        SecurityContextHolder.getContext().setAuthentication(authentication);
    }

    @Test
    void shouldGetUserById() throws Exception {
        // When & Then
        mockMvc.perform(get("/api/v1/users/me")
                        .contentType(MediaType.APPLICATION_JSON))
                .andExpect(status().isOk())
                .andExpect(jsonPath("$.name").value("John Doe"))
                .andExpect(jsonPath("$.email").value("john.doe@example.com"))
                .andExpect(jsonPath("$.phone").value("1234567890"))
                .andExpect(jsonPath("$.role").value("USER"))
                .andExpect(jsonPath("$.address").value("123 Main St"));
    }

    @Test
    void shouldCreateUser() throws Exception {
        // Given
        UserDto newUserDto = UserDto.builder()
                .name("Jane Smith")
                .email("jane.smith@example.com")
                .phone("0987654321")
                .role(Role.USER)
                .Address("456 Oak Ave")
                .build();

        // Create auth entity first and get the generated ID(as id is generated by it )
        AuthEntity newAuth = AuthEntity.builder()
                .username("janesmith")
                .password(passwordEncoder.encode("password"))
                .role(Role.USER)
                .build();
        AuthEntity savedAuth = authRepository.save(newAuth);
        UUID newUserId = savedAuth.getId();

        setupSecurityContext(newUserId.toString());


        mockMvc.perform(put("/api/v1/users/me")
                        .contentType(MediaType.APPLICATION_JSON)
                        .content(objectMapper.writeValueAsString(newUserDto)))
                .andExpect(status().isOk())
                .andExpect(jsonPath("$.name").value("Jane Smith"))
                .andExpect(jsonPath("$.email").value("jane.smith@example.com"))
                .andExpect(jsonPath("$.phone").value("0987654321"))
                .andExpect(jsonPath("$.address").value("456 Oak Ave"));
    }

    @Test
    void shouldUpdateUserDetails() throws Exception {

        UserDto updateUserDto = UserDto.builder()
                .name("John Updated")
                .email("john.updated@example.com")
                .phone("1112223333")
                .role(Role.ADMIN)
                .Address("789 Updated St")
                .build();


        mockMvc.perform(patch("/api/v1/users/me")
                        .contentType(MediaType.APPLICATION_JSON)
                        .content(objectMapper.writeValueAsString(updateUserDto)))
                .andExpect(status().isOk())
                .andExpect(jsonPath("$.name").value("John Updated"))
                .andExpect(jsonPath("$.email").value("john.updated@example.com"))
                .andExpect(jsonPath("$.phone").value("1112223333"))
                .andExpect(jsonPath("$.role").value("ADMIN"))
                .andExpect(jsonPath("$.address").value("789 Updated St"));
    }

    @Test
    void shouldReturnNotFoundWhenUserDoesNotExist() throws Exception {
        // Create auth entity and get the generated ID
        AuthEntity nonExistentAuth = AuthEntity.builder()
                .username("nonexistent")
                .password(passwordEncoder.encode("password"))
                .role(Role.USER)
                .build();
        AuthEntity savedAuth = authRepository.save(nonExistentAuth);
        UUID nonExistentUserId = savedAuth.getId();



        setupSecurityContext(nonExistentUserId.toString());

        //  Try to get user that doesn't exist
        mockMvc.perform(get("/api/v1/users/me")
                        .contentType(MediaType.APPLICATION_JSON))
                .andExpect(status().isInternalServerError()); // Since service throws RuntimeException
    }


}